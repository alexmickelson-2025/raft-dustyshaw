@using Raft;

@page "/"
@rendermode InteractiveServer

<PageTitle>DOCKER ONE</PageTitle>

<h3>Environment Variables</h3>

<strong>NODE_URLS:</strong>

@if(!Urls.Any())
{
    <div class="alert alert-danger">No urls...</div>
}

@SecretsString

@if(!nodeDict.Any())
{
    <div class="alert alert-danger">Error: no nodes</div>
}

<p>Parsed Strings</p>
@foreach (var str in Urls)
{
    <p>@str</p>
}



@* 
<div>
    <label for="speed">
        Election timeout between @(150 * Node.IntervalScalar) and @(300 *
        Node.IntervalScalar) ms.
        <br>
        <input type="range" id="speed" name="speed" min="1" max="100" @bind:event="oninput"
               @bind=Node.IntervalScalar @onchange=UpdateTimer /> @Node.IntervalScalar
    </label>
</div> *@

<div>
    <label for="NetworkRequestDelay">
        Network Delay @NetworkRequestDelay milliseconds
        <br>
        <input type="range" id="NetworkRequestDelay" name="NetworkRequestDelay" min="0" max="10000"
               @bind:event="oninput" @bind=NetworkRequestDelay />
    </label>
</div>


<div class="border border-1 shadow my-5 col-md-8 p-4 rounded">
    <h3>Send a Log</h3>
    <div class="d-flex flex-row">
        <input @bind="UserCommand" placeholder="Enter Command" class="input-group-text m-2" />
        <input @bind="UserKey" placeholder="Enter Key" class="input-group-text m-2" />
    </div>
    @foreach (var node in nodes)
    {
        <button class="btn btn-outline-primary m-3" @onclick="() => SendLog(node.NodeId)">Send To @(FormatId(node.NodeId))</button>
    }
    @if (!ClientSentLogSuccessfully)
    {
        <div class="alert alert-danger">Warning: Your command was sent to a follower node. Command was not applied.</div>
    }
    else
    {
        <p>Command applied successfully</p>
    }
</div>

<div class="row">
    @foreach (KeyValuePair<Guid , NodeData> node in nodeDict)
    {
        var timeoutRemaining = ((node.Value.WhenTimeStarted + TimeSpan.FromMilliseconds(node.Value.ElectionTimeout)) - DateTime.Now).TotalMilliseconds;
        var maxIntervalSeconds = 300 * Node.IntervalScalar;
        var percentageRemaining = (100 * (timeoutRemaining / (double)maxIntervalSeconds));


        <div class="p-3 col-4">
            <div class="border p-3 rounded-3">
                <div class="d-flex flex-column justify-content-between">
                    <h1> @(FormatId(node.Value.NodeId))</h1>
                    <div class="@StateClass(node.Value)">@node.Value.State</div>
                    <p>Election Timeout: @(@node.Value.ElectionTimeout) ms.</p>
                    <h2>Term #@node.Value.Term</h2>
                    <p>Leader Id: @(FormatId(node.Value.LeaderId))</p>
                    <div class="progress" role="progressbar"
                         aria-label="Basic example"
                         aria-valuenow=@(Math.Abs(timeoutRemaining) )
                         aria-valuemin="0"
                         aria-valuemax="@(maxIntervalSeconds)">
                        <div class="progress-bar bg-dark-subtle" style="width: @(percentageRemaining)%;"></div>
                    </div>
                    <hr />
                    <p>Commit Index: @node.Value.CommitIndex</p>
                    @* <div class="border-1 border-light m-2 p-2">
                        <strong>State Machine</strong>
                        @foreach (var commitedEntry in node.StateMachine)
                        {
                            <p>@commitedEntry.Index, @commitedEntry.Command, @commitedEntry.Key, @commitedEntry.TermReceived</p>
                        }
                    </div> *@
                    <h4 />
                    <div class="mt-3">
                        <div>
                            @foreach (var l in node.Value.Entries)
                            {
                                @if (l.Index <= node.Value.CommitIndex)
                                {
                                    <p class="text-success">&check; index:@l.Index &nbsp; <i>"@l.Command @l.Key"</i> in term @l.TermReceived </p>
                                }
                                else
                                {
                                    <p class="text-danger">&#10005; index:@l.Index &nbsp; <i>"@l.Command @l.Key"</i> in term @l.TermReceived</p>
                                }
                            }
                        </div>
                       @*  @if (node.IsRunning)
                        {
                            <button @onclick="() => pauseNode(node.InnerNode.NodeId)" class="btn btn-outline-primary">|| Pause Node</button>
                        }
                        else
                        {
                            <button @onclick="() => unpauseNode(node.InnerNode.NodeId)" class="btn btn-outline-success"> |> Play Node</button>
                        } *@
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private string SecretsString = string.Empty;

    List<string> Urls = new();

    List<NodeData> nodes = new();

    public Dictionary<Guid, NodeData> nodeDict = new();

    private Timer? timer;
    bool isRunning = false;

    public int NetworkRequestDelay = 0;


    private string UserCommand { get; set; } = "";
    private string UserKey { get; set; } = "";

    private bool ClientSentLogSuccessfully = true;

    protected override async Task OnInitializedAsync()
    {
        SecretsString = Environment.GetEnvironmentVariable("NODE_URLS") ?? throw new Exception("Node urls not set");

        HttpClient client = new();
        Urls = SecretsString.Split(";").ToList();

        Console.WriteLine("\n\n\nNODE URLS ");

        Console.WriteLine("\n\n\nSTARTING CLIENT SIM");

   
        isRunning = true;
        timer = new Timer(async _ =>
        {
            try
            {
                foreach (var url in Urls)
                {
                    // Something like "http://node2:8080/nodeData
                    var nodeStuff = await client.GetFromJsonAsync<NodeData>($"{url}/nodeData");
                    if (nodeStuff is null)
                    {
                        throw new Exception("Node stuff is null");
                    }
                    if (nodeDict.ContainsKey(nodeStuff.NodeId))
                    {
                        nodeDict[nodeStuff.NodeId] = nodeStuff;
                    }
                    else
                    {
                        nodeDict.Add(nodeStuff.NodeId, nodeStuff);
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception, ", e);
            }
            await InvokeAsync(StateHasChanged);
        }, null, 0, 200);
    }


    string StateClass(NodeData node)
    {
        if (node.State == Node.NodeState.Leader)
        {
            return "bg-primary text-white p-1 rounded";
        }
        if (node.State == Node.NodeState.Candidate)
        {
            return "bg-success text-white p-1 rounded";
        }
        if (node.State == Node.NodeState.Follower)
        {
            return "bg-secondary text-white p-1 rounded";
        }
        return "";
    }

    public static string FormatMilliSeconds(double milliSeconds)
    {
        return $"{milliSeconds / 1000.0:F1}";
    }

    public static string FormatId(Guid id)
    {
        return id.ToString("N").Substring(0, 4);
    }

    void SendLog(Guid NodeId)
    {
        foreach (var n in nodes)
        {
            if (n.NodeId == NodeId)
            {
                //ClientSentLogSuccessfully = n.RecieveClientCommand(UserCommand.ToString(), UserKey.ToString());
            }
        }
    }
}
